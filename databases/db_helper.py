import loggingimport osfrom datetime import datetimefrom typing import List, Dict, Optionalfrom dotenv import load_dotenvfrom sqlalchemy import create_engine, insert, update, selectfrom sqlalchemy.exc import SQLAlchemyErrorfrom sqlalchemy.orm import sessionmaker, Sessionfrom Classes.item import Item, metadata_objfrom databases.google_table_ranges import wacom_table_urlfrom databases.parse_db import GoogleSheetfrom tasks.client import celery_appload_dotenv()class Settings:    DB_USER = os.getenv('DB_USERNAME')    DB_PASS = os.getenv('DB_PASSWORD')    DB_HOST = os.getenv('DB_HOST')    DB_NAME = os.getenv('DB_NAME')    DB_PORT = os.getenv('DB_PORT')    @property    def db_url(self):        return f"postgresql+psycopg2://{self.DB_USER}:{self.DB_PASS}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"db = Settings()DATABASE_URL = db.db_urlengine = create_engine(DATABASE_URL, pool_size=15)session_maker = sessionmaker(engine, expire_on_commit=False)print(DATABASE_URL)google_sheet = GoogleSheet()logging.basicConfig(level=logging.INFO)def get_session():    with session_maker() as session:        return sessiondef update_database(session: Session, info_from_google_sheet: List[Dict[str, Optional[str]]]):    try:        for elem in info_from_google_sheet:            article = elem.get('article')            title = elem.get('title')            price_str = elem.get('price')            if not article or not title or not price_str:                logging.error(f"Missing or invalid fields in item: {elem}")                continue            try:                price = int(price_str)            except (ValueError, TypeError):                logging.error(f"Invalid price value: {price_str} in item: {elem}")                continue            # Проверяем, существует ли элемент в базе данных            stmt = select(Item).where(Item.article == article)            existing_item = session.execute(stmt).scalar_one_or_none()            if existing_item:                # Если элемент существует, обновляем цену                stmt = (                    update(Item)                    .where(Item.article == article)                    .values(price=price)                )                logging.info(f"Updating item: {article} with new price: {price}")            else:                # Если элемента нет, вставляем новую запись                stmt = insert(Item).values(article=article, title=title, price=price)                logging.info(f"Inserting new item: {article}, title: {title}, price: {price}")            # Выполняем запрос            session.execute(stmt)        session.commit()        current_datetime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')        logging.info(f"Database successfully updated at {current_datetime}")    except SQLAlchemyError as e:        logging.error(f"Error during database update: {e}")        session.rollback()        raise    except Exception as e:        logging.error(f"Unexpected error: {e}")        session.rollback()        raise@celery_app.taskdef update_db(table_url):    try:        table = GoogleSheet()        data = table.generate_info_from_google_sheet_list(google_sheet_url=table_url)        cleaned_data = table.clear_info_from_sheets_lists(data)        with session_maker() as sess:            update_database(sess, cleaned_data)    except Exception as e:        logging.error(f"Database was not updated: {e}")def get_info_from_db(session: Session) -> List[Item]:    try:        stmt = select(Item)        result = session.execute(stmt)        all_from_table = result.scalars().all()        items_from_db = [item for item in all_from_table]        return items_from_db    except SQLAlchemyError as e:        logging.error(f"Error fetching data from database: {e}")        raise#metadata_obj.create_all(bind=engine)# update_db(wacom_table_url)# print(get_info_from_db(session=get_session()))