import requestsfrom bs4 import BeautifulSoupfrom Classes.store import BaseStore, Soupfrom databases.parse_db import get_info_from_dbfrom utillities import get_article_from_title, clean_pricefrom WO.wo_info import WO_WACOM_ARTICLESclass WoStore(BaseStore):    def __init__(self, urls):        super().__init__(shop_url='https://wo.ua/ua/search/?q=wacom&page=1')        self.urls = urls        self.all_items = []        for url in self.urls:            soup = self.get_soup(url)            catalog_content = soup.find(class_='filtered-items')            if catalog_content:                self.all_items.append(catalog_content)            else:                print(f'No filtered-items found on page: {url}')    def get_soup(self, url):        response = requests.get(url)        response.raise_for_status()        return BeautifulSoup(response.text, 'lxml')    def generate_info(self):        self.item_list = []        try:            for items in self.all_items:                for item in items.find_all('div', class_='product-item ecom_item'):                    price_element = item.find('div', class_='product-item__bottom-price-new')                    name_element = item.find('a', class_='product-item__name')                    if price_element and name_element:                        price = price_element.text.strip().replace('.00', '')                        name = name_element.text.strip()                        if name == "ÐœÐ¾Ð½Ñ–Ñ‚Ð¾Ñ€-Ð¿Ð»Ð°Ð½ÑˆÐµÑ‚ Wacom Cintiq Pro 16 (2021) (DTH167K0B)":                            article = 'DTH167K0B'                        else:                            article = get_article_from_title(name)                        card_item = {                            'name': name,                            'price': clean_price(price),                            'article': article                        }                        self.item_list.append(card_item)        except Exception as e:            print(f"An error occurred: {e}")            return []        return self.item_list    @classmethod    def compare_all_data(cls, partner_list, articles_list):        items_from_db = list(get_info_from_db())        items_dict = {item.article: item for item in items_from_db}        missing_items = []        for elem in partner_list:            name = elem['name']            price_partner = int(elem['price']) if elem['price'] is not None else 1            article = articles_list.get(name)            if article in items_dict.keys():                item = items_dict[article]                item_price = int(item.price.decode('utf-8')) if isinstance(item.price, bytes) else int(item.price)                if price_partner == item_price:                    missing_items.append(f'âœ… {article} - Ð¦Ñ–Ð½Ð° Ð¿Ð°Ñ€Ñ‚Ð½ÐµÑ€Ð°: {price_partner} Ð³Ñ€Ð½, Ð Ð Ð¦: {item_price} Ð³Ñ€Ð½')                elif price_partner < item_price:                    missing_items.append(                        f'ðŸ›‘ Ð¦Ñ–Ð½Ð° Ð½Ð¸Ð¶Ñ‡Ð° Ð·Ð° Ð Ð Ð¦ {article} - {price_partner} Ð³Ñ€Ð½, Ð¦Ñ–Ð½Ð° Ð Ð Ð¦: {item_price} Ð³Ñ€Ð½')                else:                    missing_items.append(                        f'âš ï¸ Ð¦Ñ–Ð½Ð° Ð²Ð¸Ñ‰Ð° Ð·Ð° Ð Ð Ð¦ {article} - {price_partner} Ð³Ñ€Ð½, Ð¦Ñ–Ð½Ð° Ð Ð Ð¦: {item_price} Ð³Ñ€Ð½')            else:                missing_items.append(f'ðŸ”{article} Ð½ÐµÐ·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð² Ð±Ð°Ð·Ñ– Ð´Ð°Ð½Ð½Ð¸Ñ…')        sorted_items = sorted(missing_items, key=lambda x: (not x.startswith('âœ…'), x))        return sorted_items